syntax = "proto3";
package gravity.v1;

import "cosmos_proto/cosmos.proto";
import "google/protobuf/timestamp.proto";
import "gogoproto/gogo.proto";
import "cosmos/base/v1beta1/coin.proto";
import "google/protobuf/any.proto";

option go_package = "github.com/cosmos/gravity-bridge/module/x/gravity/types";

// EthereumEventVoteRecord is an event that is pending of confirmation by 2/3 of
// the signer set. The event is then attested and executed in the state machine
// once the required threshold is met.
message EthereumEventVoteRecord {
  google.protobuf.Any event = 1
      [ (cosmos_proto.accepts_interface) = "EthereumEvent" ];
  repeated string votes = 2;
  bool accepted = 3;
}

// LatestEthereumBlockHeight defines the latest observed ethereum block height
// and the corresponding timestamp value in nanoseconds.
message LatestEthereumBlockHeight {
  uint64 ethereum_height = 1;
  uint64 cosmos_height = 2;
}

// EthereumSigner represents a cosmos validator with its corresponding bridge
// operator ethereum address and its staking consensus power.
message EthereumSigner {
  uint64 power = 1;
  string ethereum_address = 2;
}

// UpdateSignerSetTx is the Ethereum Bridge multisig set that relays
// transactions the two chains. The staking validators keep ethereum keys which
// are used to check signatures on Ethereum in order to get significant gas
// savings.
message UpdateSignerSetTx {
  uint64 nonce = 1;
  repeated EthereumSigner signers = 2 [
    (gogoproto.castrepeated) = "EthereumSigners",
    (gogoproto.nullable) = false
  ];
}

// BatchTx represents a batch of transactions going from Cosmos to Ethereum.
// Batch txs are are identified by a unique hash and the token contract that is
// shared by all the SendToEthereum
message BatchTx {
  uint64 nonce = 1;
  uint64 timeout = 2;
  repeated SendToEthereumTx transactions = 3;
  string token_contract = 4;
  uint64 ethereum_block = 5;
}

// SendToEthereumTx represents an individual SendToEthereum from Cosmos to
// Ethereum
message SendToEthereumTx {
  uint64 id = 1;
  string sender = 2;
  string ethereum_recipient = 3;
  cosmos.base.v1beta1.Coin erc20_token = 4 [ (gogoproto.nullable) = false ];
  cosmos.base.v1beta1.Coin erc20_fee = 5 [ (gogoproto.nullable) = false ];
}

// ContractCallTx represents an individual arbitratry logic call transaction
// from Cosmos to Ethereum.
message ContractCallTx {
  uint64 invalidation_nonce = 1;
  bytes invalidation_scope = 2
      [ (gogoproto.casttype) =
            "github.com/tendermint/tendermint/libs/bytes.HexBytes" ];
  string contract_call_address = 3;
  bytes payload = 4;
  uint64 timeout = 5;
  repeated cosmos.base.v1beta1.Coin tokens = 6 [
    (gogoproto.nullable) = false,
    (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"
  ];
  repeated cosmos.base.v1beta1.Coin fees = 7 [
    (gogoproto.nullable) = false,
    (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"
  ];
}

// ERC20Token unique identifier for an Ethereum ERC20 token.
// CONTRACT:
// The contract address on ETH of the token, this could be a Cosmos
// originated token, if so it will be the ERC20 address of the representation
// (note: developers should look up the token symbol using the address on ETH to display for UI)
message ERC20Token {
  string contract = 1;
  string amount   = 2 [
    (gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int",
    (gogoproto.nullable)   = false
  ];
}

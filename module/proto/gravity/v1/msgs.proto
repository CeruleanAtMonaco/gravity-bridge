syntax = "proto3";
package gravity.v1;

import "cosmos/base/v1beta1/coin.proto";
import "cosmos_proto/cosmos.proto";
import "gravity/v1/gravity.proto";
import "gogoproto/gogo.proto";
import "google/api/annotations.proto";
import "google/protobuf/any.proto";

option go_package = "github.com/cosmos/gravity-bridge/module/x/gravity/types";

// Msg defines the state transitions possible within gravity
service Msg {
  rpc Transfer(MsgTransfer) returns (MsgTransferResponse) {
    option (google.api.http).post = "/gravity/v1/transfer";
  }
  rpc CancelTransfer(MsgCancelTransfer) returns (MsgCancelTransferResponse) {
    option (google.api.http).post = "/peggy/v1/transfer/cancel";
  }
  rpc RequestBatch(MsgRequestBatch) returns (MsgRequestBatchResponse) {
    option (google.api.http).post = "/gravity/v1/request_batch";
  }
  rpc SubmitEthereumSignature(MsgSubmitEthereumSignature) returns (MsgSubmitEthereumSignatureResponse) {
    option (google.api.http).post = "/peggy/v1/confim";
  }
  rpc SubmitEthereumEvent(MsgSubmitEthereumEvent) returns (MsgSubmitEthereumEventResponse) {
    option (google.api.http).post = "/peggy/v1/event";
  }
  rpc SetDelegateKeys(MsgDelegateKeys) returns (MsgDelegateKeysResponse) {
    option (google.api.http).post = "/peggy/v1/delegate_keys";
  }
}

// MsgTransfer submits a transfer attempt to bridge an asset over to Ethereum.
// The transfer will be stored and then included in a batch and then
// submitted to Ethereum.
message MsgTransfer {
  string                   sender        = 1;
  string                   eth_recipient = 2;
  cosmos.base.v1beta1.Coin amount        = 3 [(gogoproto.nullable) = false];
  cosmos.base.v1beta1.Coin bridge_fee    = 4 [(gogoproto.nullable) = false];
}

// MsgTransferResponse returns the transfer transaction ID which will be included
// in the batch tx.
message MsgTransferResponse { uint64 id = 1; }

// MsgCancelTransfer allows the sender to cancel its own outgoing transfer tx
// and recieve a refund of the tokens and bridge fees. This tx will only succeed
// if the transfer tx hasn't been batched to be processed and relayed to Ethereum.
message MsgCancelTransfer {
  uint64 id     = 1;
  string sender = 2;
}

message MsgCancelTransferResponse {}

// MsgRequestBatch requests a batch of transactions with a given coin denomination to send across
// the bridge to Ethereum.
message MsgRequestBatch {
  string denom  = 1;
  string signer = 2;
}

message MsgRequestBatchResponse {}

// MsgSubmitConfirm
message MsgSubmitConfirm {
  option (gogoproto.goproto_getters) = false;

  google.protobuf.Any confirm = 1 [(cosmos_proto.accepts_interface) = "Confirm"];
  string              signer  = 2;
}

// ConfirmContractCallTx confirms an outgoing logic call
message ConfirmContractCallTx {
  bytes  invalidation_id      = 1 [
    (gogoproto.casttype)   = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
  uint64 invalidation_nonce   = 2;
  string eth_signer           = 3;
  bytes  signature            = 4 [
    (gogoproto.casttype) = "github.com/ethereum/go-ethereum/common/hexutil.Bytes"
  ];
}

// ConfirmBatch an orchestrator confirms a batch transaction by signing
// with the ethereum keys on the signer set.
message ConfirmBatch {
  string token_contract = 1;
  uint64 nonce          = 2; 
  string eth_signer     = 3;
  bytes  signature      = 4 [
    (gogoproto.casttype) = "github.com/ethereum/go-ethereum/common/hexutil.Bytes"
  ];
}

// ConfirmSignerSet submits a signature of the validator set at a given block height. A validator
// must first call MsgSetEthAddress to set their Ethereum address to be used for signing.
// Finally validators sign the
// validator set, powers, and Ethereum addresses of the entire validator set at the height of a
message ConfirmSignerSet {
  uint64 nonce                = 1;
  string eth_signer           = 2;
  bytes  signature            = 3 [
    (gogoproto.casttype) = "github.com/ethereum/go-ethereum/common/hexutil.Bytes"
  ];
}

message MsgSubmitConfirmResponse {}

// MsgSubmitEvent
message MsgSubmitEvent {
  option (gogoproto.goproto_getters) = false;

  google.protobuf.Any event  = 1 [(cosmos_proto.accepts_interface) = "EthereumEvent"];
  string              signer = 2;
}

// DepositEvent is submitted when the DepositEvent is emitted by they gravity contract. 
// ERC20 representation coins are minted to the cosmosreceiver address.
message DepositEvent {
  uint64 event_nonce     = 1;
  string token_contract  = 2;
  string amount          = 3 [
    (gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", 
    (gogoproto.nullable) = false
  ];
  string ethereum_sender = 4;
  string cosmos_receiver = 5;
  uint64 ethereum_height = 6;
}

// WithdrawEvent claims that a batch of withdrawal operations on the bridge contract
// was executed successfully on ETH
message WithdrawEvent {
  string token_contract  = 1;
  uint64 event_nonce     = 2;
  uint64 ethereum_height = 3;
}

// ContractCallTxExecutedEvent describes a logic call that has been
// successfully executed on Ethereum.
message ContractCallTxExecutedEvent {
  uint64 event_nonce        = 1;
  bytes  invalidation_id    = 2 [
    (gogoproto.customname) = "InvalidationID",
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
  uint64 invalidation_nonce = 3;
  uint64 ethereum_height    = 4;
}

// CosmosERC20DeployedEvent is submitted when an ERC20 contract
// for a Cosmos SDK coin has been deployed on Ethereum.
message CosmosERC20DeployedEvent {
  uint64 event_nonce     = 1;
  string cosmos_denom    = 2;
  string token_contract  = 3;
  string name            = 4;
  string symbol          = 5;
  uint64 decimals        = 6;
  uint64 ethereum_height = 7;
}

message MsgSubmitEventResponse {}

// MsgDelegateKey allows validators to delegate their voting responsibilities
// to a given orchestrator address. This key is then used as an optional
// authentication method for attesting events from Ethereum.
message MsgDelegateKeys {
  string validator_address    = 1;
  string orchestrator_address = 2;
  string eth_address          = 3;
}

message MsgDelegateKeysResponse {}
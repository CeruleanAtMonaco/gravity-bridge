// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: peggy/v1/claims.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ClaimType int32

const (
	ClaimType_UNKNOWN             ClaimType = 0
	ClaimType_DEPOSIT             ClaimType = 1
	ClaimType_WITHDRAW            ClaimType = 2
	ClaimType_ERC20_DEPLOYED      ClaimType = 3
	ClaimType_LOGIC_CALL_EXECUTED ClaimType = 4
)

var ClaimType_name = map[int32]string{
	0: "UNKNOWN",
	1: "DEPOSIT",
	2: "WITHDRAW",
	3: "ERC20_DEPLOYED",
	4: "LOGIC_CALL_EXECUTED",
}

var ClaimType_value = map[string]int32{
	"UNKNOWN":             0,
	"DEPOSIT":             1,
	"WITHDRAW":            2,
	"ERC20_DEPLOYED":      3,
	"LOGIC_CALL_EXECUTED": 4,
}

func (x ClaimType) String() string {
	return proto.EnumName(ClaimType_name, int32(x))
}

func (ClaimType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_963ee8cc96ca73ed, []int{0}
}

// EthereumBridgeDepositClaim
// When more than 66% of the active validator set has
// claimed to have seen the deposit enter the ethereum blockchain coins are
// issued to the Cosmos address in question
// -------------
type DepositClaim struct {
	EventNonce          uint64                                 `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	BlockHeight         uint64                                 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	TokenContract       string                                 `protobuf:"bytes,3,opt,name=token_contract,json=tokenContract,proto3" json:"token_contract,omitempty"`
	Amount              github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount"`
	EthereumSender      string                                 `protobuf:"bytes,5,opt,name=ethereum_sender,json=ethereumSender,proto3" json:"ethereum_sender,omitempty"`
	CosmosReceiver      string                                 `protobuf:"bytes,6,opt,name=cosmos_receiver,json=cosmosReceiver,proto3" json:"cosmos_receiver,omitempty"`
	OrchestratorAddress string                                 `protobuf:"bytes,7,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *DepositClaim) Reset()         { *m = DepositClaim{} }
func (m *DepositClaim) String() string { return proto.CompactTextString(m) }
func (*DepositClaim) ProtoMessage()    {}
func (*DepositClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_963ee8cc96ca73ed, []int{0}
}
func (m *DepositClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositClaim.Merge(m, src)
}
func (m *DepositClaim) XXX_Size() int {
	return m.Size()
}
func (m *DepositClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositClaim.DiscardUnknown(m)
}

var xxx_messageInfo_DepositClaim proto.InternalMessageInfo

func (m *DepositClaim) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *DepositClaim) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *DepositClaim) GetTokenContract() string {
	if m != nil {
		return m.TokenContract
	}
	return ""
}

func (m *DepositClaim) GetEthereumSender() string {
	if m != nil {
		return m.EthereumSender
	}
	return ""
}

func (m *DepositClaim) GetCosmosReceiver() string {
	if m != nil {
		return m.CosmosReceiver
	}
	return ""
}

func (m *DepositClaim) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

// WithdrawClaim claims that a batch of withdrawal
// operations on the bridge contract was executed.
type WithdrawClaim struct {
	EventNonce          uint64 `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	BlockHeight         uint64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	BatchNonce          uint64 `protobuf:"varint,3,opt,name=batch_nonce,json=batchNonce,proto3" json:"batch_nonce,omitempty"`
	TokenContract       string `protobuf:"bytes,4,opt,name=token_contract,json=tokenContract,proto3" json:"token_contract,omitempty"`
	OrchestratorAddress string `protobuf:"bytes,5,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *WithdrawClaim) Reset()         { *m = WithdrawClaim{} }
func (m *WithdrawClaim) String() string { return proto.CompactTextString(m) }
func (*WithdrawClaim) ProtoMessage()    {}
func (*WithdrawClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_963ee8cc96ca73ed, []int{1}
}
func (m *WithdrawClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawClaim.Merge(m, src)
}
func (m *WithdrawClaim) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawClaim.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawClaim proto.InternalMessageInfo

func (m *WithdrawClaim) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *WithdrawClaim) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *WithdrawClaim) GetBatchNonce() uint64 {
	if m != nil {
		return m.BatchNonce
	}
	return 0
}

func (m *WithdrawClaim) GetTokenContract() string {
	if m != nil {
		return m.TokenContract
	}
	return ""
}

func (m *WithdrawClaim) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

// This informs the Cosmos module that a logic
// call has been executed
type LogicCallExecutedClaim struct {
	EventNonce          uint64 `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	BlockHeight         uint64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	InvalidationId      []byte `protobuf:"bytes,3,opt,name=invalidation_id,json=invalidationId,proto3" json:"invalidation_id,omitempty"`
	InvalidationNonce   uint64 `protobuf:"varint,4,opt,name=invalidation_nonce,json=invalidationNonce,proto3" json:"invalidation_nonce,omitempty"`
	OrchestratorAddress string `protobuf:"bytes,5,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *LogicCallExecutedClaim) Reset()         { *m = LogicCallExecutedClaim{} }
func (m *LogicCallExecutedClaim) String() string { return proto.CompactTextString(m) }
func (*LogicCallExecutedClaim) ProtoMessage()    {}
func (*LogicCallExecutedClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_963ee8cc96ca73ed, []int{2}
}
func (m *LogicCallExecutedClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicCallExecutedClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicCallExecutedClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicCallExecutedClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicCallExecutedClaim.Merge(m, src)
}
func (m *LogicCallExecutedClaim) XXX_Size() int {
	return m.Size()
}
func (m *LogicCallExecutedClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicCallExecutedClaim.DiscardUnknown(m)
}

var xxx_messageInfo_LogicCallExecutedClaim proto.InternalMessageInfo

func (m *LogicCallExecutedClaim) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *LogicCallExecutedClaim) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *LogicCallExecutedClaim) GetInvalidationId() []byte {
	if m != nil {
		return m.InvalidationId
	}
	return nil
}

func (m *LogicCallExecutedClaim) GetInvalidationNonce() uint64 {
	if m != nil {
		return m.InvalidationNonce
	}
	return 0
}

func (m *LogicCallExecutedClaim) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

// ERC20DeployedClaim allows the Cosmos module
// to learn about an ERC20 that someone deployed
// to represent a Cosmos asset
type ERC20DeployedClaim struct {
	EventNonce          uint64 `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	BlockHeight         uint64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	CosmosDenom         string `protobuf:"bytes,3,opt,name=cosmos_denom,json=cosmosDenom,proto3" json:"cosmos_denom,omitempty"`
	TokenContract       string `protobuf:"bytes,4,opt,name=token_contract,json=tokenContract,proto3" json:"token_contract,omitempty"`
	Name                string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Symbol              string `protobuf:"bytes,6,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Decimals            uint64 `protobuf:"varint,7,opt,name=decimals,proto3" json:"decimals,omitempty"`
	OrchestratorAddress string `protobuf:"bytes,8,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *ERC20DeployedClaim) Reset()         { *m = ERC20DeployedClaim{} }
func (m *ERC20DeployedClaim) String() string { return proto.CompactTextString(m) }
func (*ERC20DeployedClaim) ProtoMessage()    {}
func (*ERC20DeployedClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_963ee8cc96ca73ed, []int{3}
}
func (m *ERC20DeployedClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ERC20DeployedClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ERC20DeployedClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ERC20DeployedClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ERC20DeployedClaim.Merge(m, src)
}
func (m *ERC20DeployedClaim) XXX_Size() int {
	return m.Size()
}
func (m *ERC20DeployedClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_ERC20DeployedClaim.DiscardUnknown(m)
}

var xxx_messageInfo_ERC20DeployedClaim proto.InternalMessageInfo

func (m *ERC20DeployedClaim) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *ERC20DeployedClaim) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ERC20DeployedClaim) GetCosmosDenom() string {
	if m != nil {
		return m.CosmosDenom
	}
	return ""
}

func (m *ERC20DeployedClaim) GetTokenContract() string {
	if m != nil {
		return m.TokenContract
	}
	return ""
}

func (m *ERC20DeployedClaim) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ERC20DeployedClaim) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *ERC20DeployedClaim) GetDecimals() uint64 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *ERC20DeployedClaim) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

func init() {
	proto.RegisterEnum("peggy.v1.ClaimType", ClaimType_name, ClaimType_value)
	proto.RegisterType((*DepositClaim)(nil), "peggy.v1.DepositClaim")
	proto.RegisterType((*WithdrawClaim)(nil), "peggy.v1.WithdrawClaim")
	proto.RegisterType((*LogicCallExecutedClaim)(nil), "peggy.v1.LogicCallExecutedClaim")
	proto.RegisterType((*ERC20DeployedClaim)(nil), "peggy.v1.ERC20DeployedClaim")
}

func init() { proto.RegisterFile("peggy/v1/claims.proto", fileDescriptor_963ee8cc96ca73ed) }

var fileDescriptor_963ee8cc96ca73ed = []byte{
	// 622 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xc1, 0x4e, 0xdb, 0x4c,
	0x10, 0xc7, 0xe3, 0x60, 0x42, 0xd8, 0x84, 0x90, 0x6f, 0xe1, 0xa3, 0x16, 0x87, 0x04, 0x90, 0x5a,
	0x50, 0x25, 0x62, 0x68, 0x9f, 0x00, 0x6c, 0xb7, 0xa4, 0x8d, 0x12, 0x64, 0x82, 0xd2, 0xf6, 0xe2,
	0x6e, 0xd6, 0x23, 0xdb, 0xc2, 0xde, 0x8d, 0xec, 0x4d, 0x4a, 0xde, 0xa2, 0x2f, 0xd0, 0xd7, 0xa9,
	0x38, 0x55, 0x1c, 0xab, 0x1e, 0x50, 0x05, 0x87, 0xbe, 0x46, 0xe5, 0xb5, 0x5b, 0xa5, 0x6a, 0x23,
	0x55, 0x15, 0xa7, 0xec, 0xfc, 0x66, 0x76, 0x56, 0xff, 0x7f, 0xc6, 0x83, 0xfe, 0x1f, 0x81, 0xe7,
	0x4d, 0xf5, 0xc9, 0xa1, 0x4e, 0x43, 0x12, 0x44, 0x49, 0x6b, 0x14, 0x73, 0xc1, 0x71, 0x59, 0xe2,
	0xd6, 0xe4, 0x70, 0x73, 0xdd, 0xe3, 0x1e, 0x97, 0x50, 0x4f, 0x4f, 0x59, 0x7e, 0xe7, 0x63, 0x11,
	0x55, 0x4d, 0x18, 0xf1, 0x24, 0x10, 0x46, 0x7a, 0x0f, 0x37, 0x51, 0x05, 0x26, 0xc0, 0x84, 0xc3,
	0x38, 0xa3, 0xa0, 0x29, 0x5b, 0xca, 0x9e, 0x6a, 0x23, 0x89, 0xba, 0x29, 0xc1, 0xdb, 0xa8, 0x3a,
	0x0c, 0x39, 0xbd, 0x70, 0x7c, 0x08, 0x3c, 0x5f, 0x68, 0x45, 0x59, 0x51, 0x91, 0xec, 0x44, 0x22,
	0xfc, 0x10, 0xd5, 0x04, 0xbf, 0x00, 0xe6, 0x50, 0xce, 0x44, 0x4c, 0xa8, 0xd0, 0x16, 0xb6, 0x94,
	0xbd, 0x65, 0x7b, 0x45, 0x52, 0x23, 0x87, 0xf8, 0x19, 0x2a, 0x91, 0x88, 0x8f, 0x99, 0xd0, 0xd4,
	0x34, 0x7d, 0xdc, 0xba, 0xba, 0x69, 0x16, 0xbe, 0xdc, 0x34, 0x1f, 0x79, 0x81, 0xf0, 0xc7, 0xc3,
	0x16, 0xe5, 0x91, 0x4e, 0x79, 0x12, 0xf1, 0x24, 0xff, 0xd9, 0x4f, 0xdc, 0x0b, 0x5d, 0x4c, 0x47,
	0x90, 0xb4, 0xda, 0x4c, 0xd8, 0xf9, 0x6d, 0xbc, 0x8b, 0x56, 0x41, 0xf8, 0x10, 0xc3, 0x38, 0x72,
	0x12, 0x60, 0x2e, 0xc4, 0xda, 0xa2, 0x7c, 0xaf, 0xf6, 0x03, 0x9f, 0x49, 0x9a, 0x16, 0x66, 0x8d,
	0x9c, 0x18, 0x28, 0x04, 0x13, 0x88, 0xb5, 0x52, 0x56, 0x98, 0x61, 0x3b, 0xa7, 0xf8, 0x10, 0xad,
	0xf3, 0x98, 0xfa, 0x90, 0x88, 0x98, 0x08, 0x1e, 0x3b, 0xc4, 0x75, 0x63, 0x48, 0x12, 0x6d, 0x49,
	0x56, 0xaf, 0xcd, 0xe6, 0x8e, 0xb2, 0xd4, 0xce, 0x27, 0x05, 0xad, 0x0c, 0x02, 0xe1, 0xbb, 0x31,
	0x79, 0x77, 0x7f, 0x4e, 0x36, 0x51, 0x65, 0x48, 0x04, 0xf5, 0xf3, 0x1e, 0x0b, 0x59, 0x0f, 0x89,
	0xb2, 0x1e, 0xbf, 0x5b, 0xad, 0xfe, 0xc9, 0xea, 0x79, 0x82, 0x16, 0xe7, 0x0b, 0xfa, 0xa6, 0xa0,
	0x8d, 0x0e, 0xf7, 0x02, 0x6a, 0x90, 0x30, 0xb4, 0x2e, 0x81, 0x8e, 0x05, 0xb8, 0xf7, 0xa7, 0x6c,
	0x17, 0xad, 0x06, 0x6c, 0x42, 0xc2, 0xc0, 0x25, 0x22, 0xe0, 0xcc, 0x09, 0x5c, 0xa9, 0xae, 0x6a,
	0xd7, 0x66, 0x71, 0xdb, 0xc5, 0xfb, 0x08, 0xff, 0x52, 0x98, 0xbd, 0xa9, 0xca, 0x8e, 0xff, 0xcd,
	0x66, 0xb2, 0xa7, 0xff, 0x41, 0xe9, 0x87, 0x22, 0xc2, 0x96, 0x6d, 0x3c, 0x39, 0x30, 0x61, 0x14,
	0xf2, 0xe9, 0x7d, 0xaa, 0xdc, 0x46, 0xd5, 0x7c, 0xe2, 0x5c, 0x60, 0x3c, 0xca, 0xbf, 0x83, 0x4a,
	0xc6, 0xcc, 0x14, 0xfd, 0xed, 0x3f, 0x88, 0x91, 0xca, 0x48, 0x04, 0xb9, 0x0e, 0x79, 0xc6, 0x1b,
	0xa8, 0x94, 0x4c, 0xa3, 0x21, 0x0f, 0xf3, 0x31, 0xce, 0x23, 0xbc, 0x89, 0xca, 0x2e, 0xd0, 0x20,
	0x22, 0x61, 0x36, 0xb2, 0xaa, 0xfd, 0x33, 0x9e, 0xeb, 0x4f, 0x79, 0xae, 0x3f, 0x8f, 0xdf, 0xa2,
	0x65, 0xe9, 0x48, 0x7f, 0x3a, 0x02, 0x5c, 0x41, 0x4b, 0xe7, 0xdd, 0x97, 0xdd, 0xde, 0xa0, 0x5b,
	0x2f, 0xa4, 0x81, 0x69, 0x9d, 0xf6, 0xce, 0xda, 0xfd, 0xba, 0x82, 0xab, 0xa8, 0x3c, 0x68, 0xf7,
	0x4f, 0x4c, 0xfb, 0x68, 0x50, 0x2f, 0x62, 0x8c, 0x6a, 0xd2, 0x53, 0xc7, 0xb4, 0x4e, 0x3b, 0xbd,
	0xd7, 0x96, 0x59, 0x5f, 0xc0, 0x0f, 0xd0, 0x5a, 0xa7, 0xf7, 0xbc, 0x6d, 0x38, 0xc6, 0x51, 0xa7,
	0xe3, 0x58, 0xaf, 0x2c, 0xe3, 0xbc, 0x6f, 0x99, 0x75, 0xf5, 0xf8, 0xc5, 0xd5, 0x6d, 0x43, 0xb9,
	0xbe, 0x6d, 0x28, 0x5f, 0x6f, 0x1b, 0xca, 0xfb, 0xbb, 0x46, 0xe1, 0xfa, 0xae, 0x51, 0xf8, 0x7c,
	0xd7, 0x28, 0xbc, 0x39, 0x98, 0xd9, 0x05, 0x24, 0x14, 0x3e, 0x90, 0x7d, 0x06, 0x42, 0xcf, 0x96,
	0x5d, 0xc4, 0xdd, 0x71, 0x08, 0xfa, 0x65, 0x1e, 0xca, 0xcd, 0x30, 0x2c, 0xc9, 0xc5, 0xf6, 0xf4,
	0x7b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x2f, 0x56, 0x49, 0x11, 0x05, 0x00, 0x00,
}

func (m *DepositClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CosmosReceiver) > 0 {
		i -= len(m.CosmosReceiver)
		copy(dAtA[i:], m.CosmosReceiver)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.CosmosReceiver)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EthereumSender) > 0 {
		i -= len(m.EthereumSender)
		copy(dAtA[i:], m.EthereumSender)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.EthereumSender)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TokenContract) > 0 {
		i -= len(m.TokenContract)
		copy(dAtA[i:], m.TokenContract)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.TokenContract)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockHeight != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EventNonce != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TokenContract) > 0 {
		i -= len(m.TokenContract)
		copy(dAtA[i:], m.TokenContract)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.TokenContract)))
		i--
		dAtA[i] = 0x22
	}
	if m.BatchNonce != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.BatchNonce))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockHeight != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EventNonce != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogicCallExecutedClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicCallExecutedClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicCallExecutedClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if m.InvalidationNonce != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.InvalidationNonce))
		i--
		dAtA[i] = 0x20
	}
	if len(m.InvalidationId) > 0 {
		i -= len(m.InvalidationId)
		copy(dAtA[i:], m.InvalidationId)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.InvalidationId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockHeight != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EventNonce != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ERC20DeployedClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERC20DeployedClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ERC20DeployedClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x42
	}
	if m.Decimals != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TokenContract) > 0 {
		i -= len(m.TokenContract)
		copy(dAtA[i:], m.TokenContract)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.TokenContract)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CosmosDenom) > 0 {
		i -= len(m.CosmosDenom)
		copy(dAtA[i:], m.CosmosDenom)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.CosmosDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockHeight != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EventNonce != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintClaims(dAtA []byte, offset int, v uint64) int {
	offset -= sovClaims(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovClaims(uint64(m.EventNonce))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovClaims(uint64(m.BlockHeight))
	}
	l = len(m.TokenContract)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovClaims(uint64(l))
	l = len(m.EthereumSender)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = len(m.CosmosReceiver)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	return n
}

func (m *WithdrawClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovClaims(uint64(m.EventNonce))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovClaims(uint64(m.BlockHeight))
	}
	if m.BatchNonce != 0 {
		n += 1 + sovClaims(uint64(m.BatchNonce))
	}
	l = len(m.TokenContract)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	return n
}

func (m *LogicCallExecutedClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovClaims(uint64(m.EventNonce))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovClaims(uint64(m.BlockHeight))
	}
	l = len(m.InvalidationId)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	if m.InvalidationNonce != 0 {
		n += 1 + sovClaims(uint64(m.InvalidationNonce))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	return n
}

func (m *ERC20DeployedClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovClaims(uint64(m.EventNonce))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovClaims(uint64(m.BlockHeight))
	}
	l = len(m.CosmosDenom)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = len(m.TokenContract)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovClaims(uint64(m.Decimals))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	return n
}

func sovClaims(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozClaims(x uint64) (n int) {
	return sovClaims(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DepositClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthereumSender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthereumSender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosReceiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosReceiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchNonce", wireType)
			}
			m.BatchNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicCallExecutedClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicCallExecutedClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicCallExecutedClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvalidationId = append(m.InvalidationId[:0], dAtA[iNdEx:postIndex]...)
			if m.InvalidationId == nil {
				m.InvalidationId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidationNonce", wireType)
			}
			m.InvalidationNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidationNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERC20DeployedClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERC20DeployedClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERC20DeployedClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClaims(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClaims
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupClaims
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthClaims
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthClaims        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClaims          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupClaims = fmt.Errorf("proto: unexpected end of group")
)
